name: ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆå®Ÿè¡Œ

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

# æ¨©é™è¨­å®š
permissions:
  contents: read
  pull-requests: write
  checks: write

# åŒæ™‚å®Ÿè¡Œã®åˆ¶å¾¡
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  test:
    name: ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    runs-on: ubuntu-latest
    
    steps:
    - name: ãƒªãƒã‚¸ãƒˆãƒªã®ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
      uses: actions/checkout@v4
      
    - name: Node.jsã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: timeline-memo-app/package-lock.json
        
    - name: ä¾å­˜é–¢ä¿‚ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
      run: |
        cd timeline-memo-app
        npm ci
        
    - name: ã‚³ãƒ¼ãƒ‰ã®é™çš„è§£æï¼ˆESLintï¼‰
      run: |
        cd timeline-memo-app
        npm run lint
        
    - name: ãƒ†ã‚¹ãƒˆå®Ÿè¡Œï¼ˆã‚«ãƒãƒ¬ãƒƒã‚¸ä»˜ãï¼‰
      run: |
        cd timeline-memo-app
        npm run test:coverage
        
    - name: ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
      uses: codecov/codecov-action@v3
      if: always()
      with:
        file: ./timeline-memo-app/coverage/lcov.info
        directory: ./timeline-memo-app/coverage/
        flags: unittests
        name: timeline-memo-app-coverage
        fail_ci_if_error: false
        verbose: true
        
    - name: ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆã®ä¿å­˜
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: coverage-report
        path: timeline-memo-app/coverage/
        retention-days: 30
        
    - name: ãƒ†ã‚¹ãƒˆçµæœã®ä¿å­˜
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: |
          timeline-memo-app/coverage/
          timeline-memo-app/test-results/
        retention-days: 30

  # PRã‚³ãƒ¡ãƒ³ãƒˆç”¨ã‚¸ãƒ§ãƒ–
  comment:
    name: PRã‚³ãƒ¡ãƒ³ãƒˆæŠ•ç¨¿
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'pull_request' && always()
    
    steps:
    - name: ãƒªãƒã‚¸ãƒˆãƒªã®ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
      uses: actions/checkout@v4
      
    - name: ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
      uses: actions/download-artifact@v4
      with:
        name: coverage-report
        path: coverage/
      continue-on-error: true
        
    - name: ãƒ†ã‚¹ãƒˆçµæœã‚’PRã«ã‚³ãƒ¡ãƒ³ãƒˆ
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          
          // ãƒ†ã‚¹ãƒˆçµæœã®å–å¾—
          const testStatus = '${{ needs.test.result }}';
          let coverageData = null;
          let testFailureDetails = null;
          
          try {
            // ã‚«ãƒãƒ¬ãƒƒã‚¸æƒ…å ±ã®èª­ã¿å–ã‚Š
            const coverageSummaryPath = path.join('coverage', 'coverage-summary.json');
            if (fs.existsSync(coverageSummaryPath)) {
              const coverageContent = fs.readFileSync(coverageSummaryPath, 'utf8');
              coverageData = JSON.parse(coverageContent);
            }
          } catch (error) {
            console.log('ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿å–ã‚Šã«å¤±æ•—:', error.message);
          }
          
          // ãƒ†ã‚¹ãƒˆå¤±æ•—æ™‚ã®è©³ç´°æƒ…å ±å–å¾—
          if (testStatus === 'failure') {
            try {
              // GitHub APIã‹ã‚‰ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã®è©³ç´°ã‚’å–å¾—
              const { data: workflowRun } = await github.rest.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: context.runId
              });
              
              const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: context.runId
              });
              
              const failedJob = jobs.jobs.find(job => job.conclusion === 'failure');
              if (failedJob) {
                testFailureDetails = {
                  jobName: failedJob.name,
                  conclusion: failedJob.conclusion,
                  startedAt: failedJob.started_at,
                  completedAt: failedJob.completed_at
                };
              }
            } catch (error) {
              console.log('ãƒ†ã‚¹ãƒˆå¤±æ•—è©³ç´°ã®å–å¾—ã«å¤±æ•—:', error.message);
            }
          }
          
          // ã‚³ãƒ¡ãƒ³ãƒˆå†…å®¹ã®ä½œæˆ
          let commentBody = `## ğŸ§ª ãƒ†ã‚¹ãƒˆå®Ÿè¡Œçµæœ\n\n`;
          
          if (testStatus === 'success') {
            commentBody += `âœ… **ãƒ†ã‚¹ãƒˆæˆåŠŸ** - ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ\n\n`;
          } else if (testStatus === 'failure') {
            commentBody += `âŒ **ãƒ†ã‚¹ãƒˆå¤±æ•—** - ãƒ†ã‚¹ãƒˆã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ\n\n`;
            
            // ãƒ†ã‚¹ãƒˆå¤±æ•—ã®è©³ç´°æƒ…å ±ã‚’è¿½åŠ 
            if (testFailureDetails) {
              commentBody += `### ğŸ” å¤±æ•—è©³ç´°\n\n`;
              commentBody += `- **å¤±æ•—ã—ãŸã‚¸ãƒ§ãƒ–**: ${testFailureDetails.jobName}\n`;
              commentBody += `- **å®Ÿè¡Œæ™‚é–“**: ${new Date(testFailureDetails.startedAt).toLocaleString('ja-JP')} - ${new Date(testFailureDetails.completedAt).toLocaleString('ja-JP')}\n`;
              commentBody += `- **çµæœ**: ${testFailureDetails.conclusion}\n\n`;
            }
            
            commentBody += `### ğŸ› ï¸ å¯¾å‡¦æ–¹æ³•\n\n`;
            commentBody += `1. ãƒ­ãƒ¼ã‚«ãƒ«ã§ \`npm run test\` ã‚’å®Ÿè¡Œã—ã¦ãƒ†ã‚¹ãƒˆã‚’ç¢ºèª\n`;
            commentBody += `2. å¤±æ•—ã—ãŸãƒ†ã‚¹ãƒˆã‚’ä¿®æ­£\n`;
            commentBody += `3. \`npm run lint\` ã§ã‚³ãƒ¼ãƒ‰ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ç¢ºèª\n`;
            commentBody += `4. ä¿®æ­£å¾Œã«å†åº¦ãƒ—ãƒƒã‚·ãƒ¥\n\n`;
          } else {
            commentBody += `âš ï¸ **ãƒ†ã‚¹ãƒˆçŠ¶æ…‹ä¸æ˜** - ãƒ†ã‚¹ãƒˆã®å®Ÿè¡ŒçŠ¶æ…‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„\n\n`;
          }
          
          // ã‚«ãƒãƒ¬ãƒƒã‚¸æƒ…å ±ã®è¿½åŠ 
          if (coverageData && coverageData.total) {
            const { lines, functions, branches, statements } = coverageData.total;
            
            commentBody += `### ğŸ“Š ã‚³ãƒ¼ãƒ‰ã‚«ãƒãƒ¬ãƒƒã‚¸\n\n`;
            commentBody += `| é …ç›® | ã‚«ãƒãƒ¬ãƒƒã‚¸ |\n`;
            commentBody += `|------|----------|\n`;
            commentBody += `| è¡Œ | ${lines.pct}% (${lines.covered}/${lines.total}) |\n`;
            commentBody += `| é–¢æ•° | ${functions.pct}% (${functions.covered}/${functions.total}) |\n`;
            commentBody += `| åˆ†å² | ${branches.pct}% (${branches.covered}/${branches.total}) |\n`;
            commentBody += `| æ–‡ | ${statements.pct}% (${statements.covered}/${statements.total}) |\n\n`;
            
            // ã‚«ãƒãƒ¬ãƒƒã‚¸ã—ãã„å€¤ã®ç¢ºèª
            const threshold = 80;
            const overallCoverage = Math.min(lines.pct, functions.pct, branches.pct, statements.pct);
            
            if (overallCoverage >= threshold) {
              commentBody += `âœ… ã‚«ãƒãƒ¬ãƒƒã‚¸ã—ãã„å€¤ï¼ˆ${threshold}%ï¼‰ã‚’æº€ãŸã—ã¦ã„ã¾ã™\n\n`;
            } else {
              commentBody += `âš ï¸ ã‚«ãƒãƒ¬ãƒƒã‚¸ã—ãã„å€¤ï¼ˆ${threshold}%ï¼‰ã‚’ä¸‹å›ã£ã¦ã„ã¾ã™ï¼ˆç¾åœ¨: ${overallCoverage}%ï¼‰\n\n`;
            }
          }
          
          commentBody += `### ğŸ”— è©³ç´°æƒ…å ±\n\n`;
          commentBody += `- [ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œçµæœ](${context.payload.pull_request.html_url}/checks)\n`;
          commentBody += `- [ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆ](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})\n\n`;
          commentBody += `---\n`;
          commentBody += `*ã“ã®ã‚³ãƒ¡ãƒ³ãƒˆã¯è‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã—ãŸï¼ˆå®Ÿè¡ŒID: ${context.runId}ï¼‰*`;
          
          // æ—¢å­˜ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’æ¤œç´¢
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });
          
          const botComment = comments.find(comment => 
            comment.user.type === 'Bot' && 
            comment.body.includes('ğŸ§ª ãƒ†ã‚¹ãƒˆå®Ÿè¡Œçµæœ')
          );
          
          // ã‚³ãƒ¡ãƒ³ãƒˆã®æŠ•ç¨¿ã¾ãŸã¯æ›´æ–°
          if (botComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: commentBody
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });
          }